import React, { useState, useEffect, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/shared/components/ui/Card';
import { Badge } from '@/shared/components/ui/Badge';
import { Button } from '@/shared/components/ui/Button';
import { Input } from '@/shared/components/ui/Input';
import { Textarea } from '@/shared/components/ui/Textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/shared/components/ui/Select';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/shared/components/ui/Dialog';
import { Progress } from '@/shared/components/ui/Progress';
import { Label } from '@/shared/components/ui/Label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/shared/components/ui/Tabs';
import { useAuth } from '@/core/auth/AuthProvider';
import { supabase } from '@/core/supabase';
import {
  Brain,
  Database,
  Cpu,
  Network,
  Activity,
  Plus,
  Search,
  RefreshCw,
  TrendingUp,
  X,
  CheckCircle2,
  AlertCircle,
  Lightbulb,
  ArrowRight,
  Eye
} from 'lucide-react';

interface KnowledgeTruth {
  id: string;
  title: string;
  description: string;
  category: 'business' | 'personal' | 'technical' | 'strategic' | 'operational';
  confidence: number;
  source: string;
  evidence: string[];
  impact: 'high' | 'medium' | 'low';
  status: 'verified' | 'pending' | 'disputed' | 'archived';
  tags: string[];
  createdat: Date;
  updatedat: Date;
  verified_by?: string;
  verification_date?: Date;
  relatedthoughts: string[];
  relatedinsights: string[];
  actionable: boolean;
  actionitems: string[];
  // Living RAG additions
  datasources: string[];
  lastdataupdate: Date;
  correlationstrength: number;
  predictionaccuracy: number;
  autogenerated: boolean;
}

interface KnowledgeInsight {
  id: string;
  title: string;
  description: string;
  type: 'pattern' | 'trend' | 'anomaly' | 'opportunity' | 'risk' | 'prediction';
  source: string;
  confidence: number;
  impact: 'high' | 'medium' | 'low';
  urgency: 'immediate' | 'today' | 'this-week' | 'ongoing';
  dataPoints: number;
  lastUpdated: Date;
  actionable: boolean;
  actionUrl?: string;
  relatedIntegrations: string[];
  aiGenerated: boolean;
  // Living RAG additions
  realtime: boolean;
  datastream: string[];
  updatefrequency: string;
  crossplatformcorrelation: boolean;
}

interface IntegrationDataStream {
  id: string;
  integrationname: string;
  datatype: string;
  lastsync: Date;
  recordcount: number;
  status: 'active' | 'inactive' | 'error';
  truthcontributions: number;
  insightgenerations: number;
}

interface KnowledgeCenterProps {
  className?: string;
}

export const KnowledgeCenter: React.FC<KnowledgeCenterProps> = ({ className = '' }) => {
  const { user } = useAuth();
  const [truths, setTruths] = useState<KnowledgeTruth[]>([]);
  const [insights, setInsights] = useState<KnowledgeInsight[]>([]);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState('truths');
  const [selectedCategory, setSelectedCategory] = useState<string>('all');
  const [searchQuery, setSearchQuery] = useState('');
  // Living RAG System State
  const [dataStreams, setDataStreams] = useState<IntegrationDataStream[]>([]);
  const [realTimeUpdates, setRealTimeUpdates] = useState(false);
  const [autoDiscoveryEnabled, setAutoDiscoveryEnabled] = useState(false);
  const [lastDiscoveryRun, setLastDiscoveryRun] = useState<Date | null>(null);
  const [discoveryProgress, setDiscoveryProgress] = useState(0);
  const [activeDataSources, setActiveDataSources] = useState<string[]>([]);
  const [showAddTruth, setShowAddTruth] = useState(false);
  const [selectedTruth, setSelectedTruth] = useState<KnowledgeTruth | null>(null);
  const [newTruth, setNewTruth] = useState({
    title: '',
    description: '',
    category: 'business' as const,
    evidence: [''],
    tags: [''],
    actionitems: ['']
  });

  useEffect(() => {
    if (user?.id) {
      loadKnowledgeData();
      setupLivingRAGSystem();
    }
  }, [user?.id]);

  const setupLivingRAGSystem = useCallback(async () => {
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.log('ðŸ”„ Setting up Living RAG System...');
    
    try {
      await initializeDataStreams();
      await setupRealTimeSubscriptions();
      await startAutomaticDiscovery();
      
      setRealTimeUpdates(true);
      setAutoDiscoveryEnabled(true);
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error setting up Living RAG System: ', error);
    }
  }, []);

  // Initialize data streams from active integrations
  const initializeDataStreams = async () => {
    try {
      const { data: integrations } = await supabase
        .from('user_integrations')
        .select(`
          id,
          integration_name,
          status,
          last_sync_at
        `)
        .eq('user_id', user?.id || '')
        .eq('status', 'active');

      if (integrations) {
        const streams: IntegrationDataStream[] = integrations.map(integration => {
          return {
            id: integration.id,
            integrationname: integration.integration_name || 'Unknown',
            datatype: 'general',
            lastsync: new Date(integration.last_sync_at || Date.now()),
            recordcount: 0, // Will be updated by data analysis
            status: integration.status as 'active' | 'inactive' | 'error',
            truthcontributions: 0,
            insightgenerations: 0
          };
        });

        setDataStreams(streams);
        setActiveDataSources(streams.map(s => s.integration_name));
      }
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error initializing data streams: ', error);
    }
  };

  // Set up real-time subscriptions for live updates
  const setupRealTimeSubscriptions = () => {
    // Subscribe to integration data changes
    const integrationChannel = supabase
      .channel('integration-data-changes')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'integration_data'
      }, (payload) => {
        // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.log('Integration data changed: ', payload);
        handleDataStreamUpdate(payload);
      })
      .subscribe();

    // Subscribe to thought changes
    const thoughtsChannel = supabase
      .channel('thoughts-changes')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'thoughts'
      }, (payload) => {
        // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.log('Thought changed: ', payload);
        handleThoughtUpdate(payload);
      })
      .subscribe();

    return () => {
      supabase.removeChannel(integrationChannel);
      supabase.removeChannel(thoughtsChannel);
    };
  };

  const handleDataStreamUpdate = useCallback(async (_payload: any) => {
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.log('ðŸ“Š Data stream update received: ', payload);
    
    if (payload.new) {
      await discoverIntegrationPatterns(payload.new);
    }
  }, []);

  const handleThoughtUpdate = useCallback(async (_payload: any) => {
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.log('ðŸ’­ Thought update received: ', payload);
    
    if (payload.new) {
      await analyzeThoughtForTruths(payload.new);
    }
  }, []);

  // Start automatic truth discovery process
  const startAutomaticDiscovery = async () => {
    setDiscoveryProgress(0);
    
    try {
      // 1. Analyze integration data for patterns
      await discoverIntegrationPatterns();
      setDiscoveryProgress(25);
      
      // 2. Cross-platform correlation analysis
      await performCrossPlatformAnalysis();
      setDiscoveryProgress(50);
      
      // 3. Generate predictive insights
      await generatePredictiveInsights();
      setDiscoveryProgress(75);
      
      // 4. Update existing truths with new data
      await updateExistingTruths();
      setDiscoveryProgress(100);
      
      setLastDiscoveryRun(new Date());
      
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error in automatic discovery: ', error);
    }
  };

  // Discover new truths from integration data
  const discoverIntegrationPatterns = async () => {
    try {
      // Get recent integration data
      const { data: integrationData } = await supabase
        .from('integration_data')
        .select('*')
        .eq('user_id', user?.id)
        .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString())
        .order('created_at', { ascending: false });

      if (integrationData && integrationData.length > 0) {
        // Group by integration type
        const groupedData = integrationData.reduce((acc, data) => {
          const source = data.source || 'unknown';
          if (!acc[source]) acc[source] = [];
          acc[source].push(data);
          return acc;
        }, {} as Record<string, any[]>);

        // Analyze each integration type for patterns
        for (const [source, data] of Object.entries(groupedData)) {
          const patterns = await analyzeIntegrationPatterns(source, data);
          if (patterns.length > 0) {
            const newTruths = patterns.map(pattern => ({
              id: `auto-${source}-${Date.now()}-${Math.random()}`,
              title: pattern.title,
              description: pattern.description,
              category: pattern.category,
              confidence: pattern.confidence,
              source: `Auto-discovery from ${source}`,
              evidence: pattern.evidence,
              impact: pattern.impact,
              status: 'pending' as const,
              tags: pattern.tags,
              createdat: new Date(),
              updatedat: new Date(),
              relatedthoughts: [],
              relatedinsights: [],
              actionable: pattern.actionable,
              actionitems: pattern.action_items,
              datasources: [source],
              lastdata_update: new Date(),
              correlationstrength: pattern.correlation_strength,
              predictionaccuracy: pattern.prediction_accuracy,
              autogenerated: true
            }));
            
            setTruths(prev => [...prev, ...newTruths]);
          }
        }
      }
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error discovering integration patterns: ', error);
    }
  };

  // Analyze patterns in integration data
  const analyzeIntegrationPatterns = async (source: string, data: any[]): Promise<any[]> => {
    const patterns: any[] = [];
    
    // Example pattern analysis (simplified)
    if (source === 'hubspot' && data.length > 10) {
      // Analyze sales patterns
      const dealData = data.filter(d => d.type === 'deal');
      if (dealData.length > 5) {
        const avgDealSize = dealData.reduce((sum, d) => sum + (d.value?.amount || 0), 0) / dealData.length;
        const conversionRate = dealData.filter(d => d.value?.status === 'closed').length / dealData.length;
        
        if (conversionRate > 0.3) {
          patterns.push({
            title: 'High Sales Conversion Rate',
            description: `Sales conversion rate of ${(conversionRate * 100).toFixed(1)}% indicates effective sales process`,
            category: 'business',
            confidence: 0.85,
            evidence: [
              `${dealData.length} deals analyzed`,
              `${(conversionRate * 100).toFixed(1)}% conversion rate`,
              `Average deal size: $${avgDealSize.toLocaleString()}`
            ],
            impact: 'high',
            tags: ['sales', 'conversion', 'hubspot'],
            actionable: true,
            actionitems: [
              'Scale successful sales tactics',
              'Document winning strategies',
              'Train team on best practices'
            ],
            correlationstrength: 0.88,
            predictionaccuracy: 0.82
          });
        }
      }
    }
    
    return patterns;
  };

  // Perform cross-platform correlation analysis
  const performCrossPlatformAnalysis = async () => {
    try {
      // Get data from multiple integrations
      const { data: multiPlatformData } = await supabase
        .from('integration_data')
        .select('*')
        .eq('user_id', user?.id)
        .in('source', ['hubspot', 'stripe', 'google-analytics'])
        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());

      if (multiPlatformData && multiPlatformData.length > 0) {
        // Find correlations between different data sources
        const correlations = await findCrossPlatformCorrelations(multiPlatformData);
        
        // Convert correlations to insights
        const newInsights = correlations.map(correlation => ({
          id: `correlation-${Date.now()}-${Math.random()}`,
          title: correlation.title,
          description: correlation.description,
          type: 'pattern' as const,
          source: 'Cross-platform Analysis',
          confidence: correlation.confidence,
          impact: correlation.impact,
          urgency: 'ongoing' as const,
          dataPoints: correlation.dataPoints,
          lastUpdated: new Date(),
          actionable: true,
          actionUrl: correlation.actionUrl,
          relatedIntegrations: correlation.platforms,
          aiGenerated: true,
          realtime: true,
          datastream: correlation.platforms,
          updatefrequency: 'daily',
          crossplatform_correlation: true
        }));
        
        setInsights(prev => [...prev, ...newInsights]);
      }
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error performing cross-platform analysis: ', error);
    }
  };

  // Find correlations between different platforms
  const findCrossPlatformCorrelations = async (data: any[]): Promise<any[]> => {
    const correlations: any[] = [];
    
    // Group data by platform
    const platformData = data.reduce((acc, item) => {
      if (!acc[item.source]) acc[item.source] = [];
      acc[item.source].push(item);
      return acc;
    }, {} as Record<string, any[]>);
    
    // Example correlation: Email volume vs Sales
    if (platformData['google-analytics'] && platformData['hubspot']) {
      const emailData = platformData['google-analytics'].filter(d => d.type === 'email_volume');
      const salesData = platformData['hubspot'].filter(d => d.type === 'deal');
      
      if (emailData.length > 5 && salesData.length > 5) {
        // Simple correlation analysis (in real implementation, use statistical methods)
        const avgEmailVolume = emailData.reduce((sum, d) => sum + (d.value || 0), 0) / emailData.length;
        const avgSales = salesData.reduce((sum, d) => sum + (d.value?.amount || 0), 0) / salesData.length;
        
        if (avgEmailVolume > 100 && avgSales > 50000) {
          correlations.push({
            title: 'Email Activity Correlates with Sales',
            description: 'Higher email volume shows correlation with increased sales activity',
            confidence: 0.78,
            impact: 'medium',
            dataPoints: emailData.length + salesData.length,
            actionUrl: '/workspace/sales-dashboard',
            platforms: ['google-analytics', 'hubspot']
          });
        }
      }
    }
    
    return correlations;
  };

  // Generate predictive insights
  const generatePredictiveInsights = async () => {
    try {
      // Analyze trends and make predictions
      const predictions = await analyzeTrendsForPredictions();
      
      const newInsights = predictions.map(prediction => ({
        id: `prediction-${Date.now()}-${Math.random()}`,
        title: prediction.title,
        description: prediction.description,
        type: 'prediction' as const,
        source: 'AI Trend Analysis',
        confidence: prediction.confidence,
        impact: prediction.impact,
        urgency: prediction.urgency,
        dataPoints: prediction.dataPoints,
        lastUpdated: new Date(),
        actionable: true,
        actionUrl: prediction.actionUrl,
        relatedIntegrations: prediction.sources,
        aiGenerated: true,
        realtime: true,
        datastream: prediction.sources,
        updatefrequency: 'weekly',
        crossplatform_correlation: true
      }));
      
      setInsights(prev => [...prev, ...newInsights]);
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error generating predictive insights: ', error);
    }
  };

  // Analyze trends for predictions
  const analyzeTrendsForPredictions = async (): Promise<any[]> => {
    const predictions: any[] = [];
    
    try {
      // Get historical data for trend analysis
      const { data: historicalData } = await supabase
        .from('integration_data')
        .select('*')
        .eq('user_id', user?.id)
        .gte('created_at', new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString())
        .order('created_at', { ascending: true });

      if (historicalData && historicalData.length > 20) {
        // Example: Revenue trend prediction
        const revenueData = historicalData.filter(d => d.type === 'revenue');
        if (revenueData.length > 10) {
          const recentRevenue = revenueData.slice(-5).reduce((sum, d) => sum + (d.value || 0), 0);
          const olderRevenue = revenueData.slice(-10, -5).reduce((sum, d) => sum + (d.value || 0), 0);
          const growthRate = (recentRevenue - olderRevenue) / olderRevenue;
          
          if (growthRate > 0.1) {
            predictions.push({
              title: 'Strong Revenue Growth Trend',
              description: `Revenue growing at ${(growthRate * 100).toFixed(1)}% monthly rate`,
              confidence: 0.82,
              impact: 'high',
              urgency: 'this-week',
              dataPoints: revenueData.length,
              actionUrl: '/workspace/financial-dashboard',
              sources: ['stripe', 'quickbooks']
            });
          }
        }
      }
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error analyzing trends: ', error);
    }
    
    return predictions;
  };

  // Update existing truths with new data
  const updateExistingTruths = async () => {
    try {
      // Get recent data to update existing truths
      const { data: recentData } = await supabase
        .from('integration_data')
        .select('*')
        .eq('user_id', user?.id)
        .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString());

      if (recentData && recentData.length > 0) {
        setTruths(prev => prev.map(truth => {
          // Update auto-generated truths with new data
          if (truth.auto_generated && truth.data_sources.length > 0) {
            const relevantData = recentData.filter(d => 
              truth.data_sources.some(source => d.source?.includes(source))
            );
            
            if (relevantData.length > 0) {
              return {
                ...truth,
                updatedat: new Date(),
                lastdata_update: new Date(),
                confidence: Math.min(truth.confidence + 0.02, 0.95), // Slight confidence boost
                evidence: [...truth.evidence, `Updated with ${relevantData.length} new data points`]
              };
            }
          }
          return truth;
        }));
      }
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error updating existing truths: ', error);
    }
  };

  // Analyze new thought for potential truths
  const analyzeThoughtForTruths = async (__thought: any) => {
    try {
      // Simple analysis - in real implementation, use AI/ML
      const content = thought.content?.toLowerCase() || '';
      
      if (content.includes('productivity') || content.includes('efficiency')) {
        const newTruth: KnowledgeTruth = {
          id: `thought-${thought.id}-${Date.now()}`,
          title: 'Productivity Focus Detected',
          description: 'Recent thoughts show strong focus on productivity and efficiency improvements',
          category: 'personal',
          confidence: 0.75,
          source: 'Thought Analysis',
          evidence: [thought.content],
          impact: 'medium',
          status: 'pending',
          tags: ['productivity', 'efficiency', 'personal-development'],
          createdat: new Date(),
          updatedat: new Date(),
          relatedthoughts: [thought.id],
          relatedinsights: [],
          actionable: true,
          actionitems: [
            'Document productivity strategies',
            'Share insights with team',
            'Track productivity improvements'
          ],
          datasources: ['thought_analysis'],
          lastdata_update: new Date(),
          correlationstrength: 0.80,
          predictionaccuracy: 0.75,
          autogenerated: true
        };
        
        setTruths(prev => [...prev, newTruth]);
      }
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error analyzing thought for truths: ', error);
    }
  };

  const loadKnowledgeData = useCallback(async () => {
    if (!user) return;
    
    setLoading(true);
    try {
      const [truthsData, insightsData] = await Promise.all([
        fetchKnowledgeTruths(),
        fetchKnowledgeInsights()
      ]);

      setTruths(truthsData);
      setInsights(insightsData);
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error loading knowledge data: ', error);
    } finally {
      setLoading(false);
    }
  }, [user]);

  const fetchKnowledgeTruths = async (): Promise<KnowledgeTruth[]> => {
    const truths: KnowledgeTruth[] = [];

    try {
      // Get thoughts and analyze them for truths
      const { data: thoughts } = await supabase
        .from('thoughts')
        .select('*')
        .eq('user_id', user?.id)
        .order('created_at', { ascending: false });

      if (thoughts && thoughts.length > 0) {
        // Analyze thoughts for patterns and truths
        const thoughtPatterns = analyzeThoughtPatterns(thoughts);
        
        // Business truths
        if (thoughtPatterns.productivityTrend === 'improving') {
          truths.push({
            id: 'productivity-improvement',
            title: 'Productivity Improvement Pattern',
            description: 'Your task completion rates have increased consistently, indicating improved focus and efficiency.',
            category: 'business',
            confidence: 0.85,
            source: 'Thought Analysis',
            evidence: [
              'Task completion rate increased by 18%',
              'Focus areas show consistent progress',
              'Time management patterns improved'
            ],
            impact: 'high',
            status: 'verified',
            tags: ['productivity', 'efficiency', 'focus'],
            createdat: new Date(),
            updatedat: new Date(),
            verifiedby: user?.id,
            verificationdate: new Date(),
            relatedthoughts: thoughts.filter(t => t.category === 'task').map(t => t.id),
            relatedinsights: [],
            actionable: true,
            actionitems: [
              'Maintain current productivity practices',
              'Scale successful time management techniques',
              'Document best practices for team sharing'
            ],
            // Living RAG additions
            datasources: ['thought_analysis'],
            lastdata_update: new Date(),
            correlationstrength: 0.95,
            predictionaccuracy: 0.92,
            autogenerated: true
          });
        }

        // Personal truths
        const personalThoughts = thoughts.filter(t => t.personal_or_professional === 'personal');
        if (personalThoughts.length > 0) {
          const personalPatterns = analyzePersonalPatterns(personalThoughts);
          
          if (personalPatterns.learningFocus) {
            truths.push({
              id: 'learning-focus',
              title: 'Strong Learning Orientation',
              description: 'Your thoughts consistently show a focus on learning and skill development.',
              category: 'personal',
              confidence: 0.78,
              source: 'Personal Thought Analysis',
              evidence: [
                'High frequency of learning-related thoughts',
                'Consistent focus on skill development',
                'Growth mindset patterns detected'
              ],
              impact: 'medium',
              status: 'verified',
              tags: ['learning', 'growth', 'personal-development'],
              createdat: new Date(),
              updatedat: new Date(),
              verifiedby: user?.id,
              verificationdate: new Date(),
              relatedthoughts: personalThoughts.map(t => t.id),
              relatedinsights: [],
              actionable: true,
              actionitems: [
                'Continue investing in learning opportunities',
                'Share knowledge with team members',
                'Document learning insights for future reference'
              ],
              // Living RAG additions
              datasources: ['personal_thought_analysis'],
              lastdata_update: new Date(),
              correlationstrength: 0.88,
              predictionaccuracy: 0.85,
              autogenerated: true
            });
          }
        }

        // Strategic truths
        const strategicThoughts = thoughts.filter(t => t.category === 'idea' && t.initiative);
        if (strategicThoughts.length > 0) {
          truths.push({
            id: 'strategic-thinking',
            title: 'Strategic Initiative Focus',
            description: 'You consistently generate and pursue strategic initiatives that align with long-term goals.',
            category: 'strategic',
            confidence: 0.82,
            source: 'Strategic Thought Analysis',
            evidence: [
              'Multiple strategic initiatives identified',
              'Consistent alignment with business goals',
              'Initiative follow-through patterns'
            ],
            impact: 'high',
            status: 'verified',
            tags: ['strategy', 'initiatives', 'planning'],
            createdat: new Date(),
            updatedat: new Date(),
            verifiedby: user?.id,
            verificationdate: new Date(),
            relatedthoughts: strategicThoughts.map(t => t.id),
            relatedinsights: [],
            actionable: true,
            actionitems: [
              'Prioritize strategic initiatives by impact',
              'Create execution roadmaps for top initiatives',
              'Track progress on strategic goals'
            ],
            // Living RAG additions
            datasources: ['strategic_thought_analysis'],
            lastdata_update: new Date(),
            correlationstrength: 0.90,
            predictionaccuracy: 0.88,
            autogenerated: true
          });
        }
      }

      // Get business insights and convert to truths
      const { data: businessData } = await supabase
        .from('business_profiles')
        .select('*')
        .eq('org_id', user?.profile?.company_id || user?.id)
        .single();

      if (businessData) {
        if (businessData.revenue_trend === 'growing') {
          truths.push({
            id: 'revenue-growth',
            title: 'Sustainable Revenue Growth',
            description: 'Your business shows consistent revenue growth patterns with healthy customer acquisition.',
            category: 'business',
            confidence: 0.88,
            source: 'Business Analytics',
            evidence: [
              'Consistent revenue growth trend',
              'Healthy customer acquisition metrics',
              'Strong retention patterns'
            ],
            impact: 'high',
            status: 'verified',
            tags: ['revenue', 'growth', 'business-health'],
            createdat: new Date(),
            updatedat: new Date(),
            verifiedby: user?.id,
            verificationdate: new Date(),
            relatedthoughts: [],
            relatedinsights: [],
            actionable: true,
            actionitems: [
              'Maintain current growth strategies',
              'Scale successful customer acquisition channels',
              'Invest in customer retention programs'
            ],
            // Living RAG additions
            datasources: ['business_analytics'],
            lastdata_update: new Date(),
            correlationstrength: 0.92,
            predictionaccuracy: 0.90,
            autogenerated: true
          });
        }
      }

    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error fetching knowledge truths: ', error);
    }

    return truths;
  };

  const fetchKnowledgeInsights = async (): Promise<KnowledgeInsight[]> => {
    const insights: KnowledgeInsight[] = [];

    try {
      // Get insights from business data
      const { data: businessData } = await supabase
        .from('business_profiles')
        .select('*')
        .eq('org_id', user?.profile?.company_id || user?.id)
        .single();

      if (businessData) {
        // Revenue pattern analysis
        if (businessData.revenue_trend === 'declining') {
          insights.push({
            id: 'revenue-decline-pattern',
            title: 'Revenue Decline Pattern Detected',
            description: 'Consistent decline in revenue over the last 3 months. Pattern suggests pricing or market issues.',
            type: 'trend',
            source: 'Financial Analytics',
            confidence: 0.85,
            impact: 'high',
            urgency: 'immediate',
            dataPoints: 12,
            lastUpdated: new Date(),
            actionable: true,
            actionUrl: '/workspace/business-dashboard',
            relatedIntegrations: ['stripe', 'paypal', 'quickbooks'],
            aiGenerated: true,
            // Living RAG additions
            realtime: true,
            datastream: ['financial_data'],
            updatefrequency: 'daily',
            crossplatform_correlation: true
          });
        }

        // Customer behavior insights
        if (businessData.customer_satisfaction_score && businessData.customer_satisfaction_score < 7) {
          insights.push({
            id: 'customer-satisfaction-trend',
            title: 'Customer Satisfaction Trend Analysis',
            description: 'Customer satisfaction scores trending downward. Correlation with support response times detected.',
            type: 'pattern',
            source: 'Customer Analytics',
            confidence: 0.78,
            impact: 'high',
            urgency: 'this-week',
            dataPoints: 45,
            lastUpdated: new Date(),
            actionable: true,
            actionUrl: '/workspace/customer-insights',
            relatedIntegrations: ['hubspot', 'zendesk', 'intercom'],
            aiGenerated: true,
            // Living RAG additions
            realtime: true,
            datastream: ['customer_feedback'],
            updatefrequency: 'weekly',
            crossplatform_correlation: true
          });
        }
      }

      // Get insights from thought patterns
      const { data: thoughts } = await supabase
        .from('thoughts')
        .select('*')
        .eq('user_id', user?.id)
        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());

      if (thoughts && thoughts.length > 0) {
        const thoughtPatterns = analyzeThoughtPatterns(thoughts);
        
        if (thoughtPatterns.productivityTrend === 'improving') {
          insights.push({
            id: 'productivity-improvement',
            title: 'Productivity Improvement Pattern',
            description: 'Task completion rates increased 18% this month. Focus areas: automation and time management.',
            type: 'trend',
            source: 'Personal Analytics',
            confidence: 0.81,
            impact: 'medium',
            urgency: 'ongoing',
            dataPoints: thoughts.length,
            lastUpdated: new Date(),
            actionable: true,
            actionUrl: '/knowledge/thoughts',
            relatedIntegrations: ['notion', 'asana', 'trello'],
            aiGenerated: true,
            // Living RAG additions
            realtime: true,
            datastream: ['task_completion_data'],
            updatefrequency: 'monthly',
            crossplatform_correlation: true
          });
        }
      }

    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error fetching knowledge insights: ', error);
    }

    return insights;
  };

  const analyzeThoughtPatterns = (thoughts: any[]) => {
    const completedTasks = thoughts.filter(t => t.status === 'completed').length;
    const totalTasks = thoughts.filter(t => t.category === 'task').length;
    const completionRate = totalTasks > 0 ? completedTasks / totalTasks: 0;

    return {
      productivityTrend: completionRate > 0.7 ? 'improving' : 'declining',
      focusAreas: thoughts
        .filter(t => t.department)
        .reduce((acc: any, t) => {
          acc[t.department] = (acc[t.department] || 0) + 1;
          return acc;
        }, {}),
      completionRate
    };
  };

  const analyzePersonalPatterns = (thoughts: any[]) => {
    const learningKeywords = ['learn', 'study', 'skill', 'knowledge', 'training', 'education'];
    const learningThoughts = thoughts.filter(t => 
      learningKeywords.some(keyword => 
        t.content?.toLowerCase().includes(keyword)
      )
    );

    return {
      learningFocus: learningThoughts.length > thoughts.length * 0.3,
      learningPercentage: (learningThoughts.length / thoughts.length) * 100
    };
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await loadKnowledgeData();
    setRefreshing(false);
  };

  const handleVerifyTruth = async (truthId: string) => {
    try {
      const updatedTruths = truths.map(truth => 
        truth.id === truthId 
          ? { ...truth, status: 'verified' as const, verifiedby: user?.id, verificationdate: new Date() }
          : truth
      );
      setTruths(updatedTruths);
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error verifying truth: ', error);
    }
  };

  const handleDisputeTruth = async (truthId: string) => {
    try {
      const updatedTruths = truths.map(truth => 
        truth.id === truthId 
          ? { ...truth, status: 'disputed' as const }
          : truth
      );
      setTruths(updatedTruths);
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error disputing truth: ', error);
    }
  };

  const handleAddTruth = async () => {
    try {
      const truth: KnowledgeTruth = {
        id: `truth-${Date.now()}`,
        title: newTruth.title,
        description: newTruth.description,
        category: newTruth.category,
        confidence: newTruth.confidence,
        source: newTruth.source,
        evidence: newTruth.evidence.filter(e => e.trim() !== ''),
        impact: newTruth.impact,
        status: 'pending',
        tags: newTruth.tags.filter(t => t.trim() !== ''),
        createdat: new Date(),
        updatedat: new Date(),
        relatedthoughts: [],
        relatedinsights: [],
        actionable: newTruth.actionable,
        actionitems: newTruth.action_items.filter(a => a.trim() !== '')
      };

      setTruths(prev => [truth, ...prev]);
      setShowAddTruth(false);
      
      // Reset form
      setNewTruth({
        title: '',
        description: '',
        category: 'business',
        confidence: 0.8,
        source: '',
        evidence: [''],
        impact: 'medium',
        tags: [''],
        actionable: true,
        actionitems: ['']
      });
    } catch (error) {
      // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    // eslint-disable-next-line no-console
    console.error('Error adding truth: ', error);
    }
  };

  const handleAddEvidence = () => {
    setNewTruth(prev => ({
      ...prev,
      evidence: [...prev.evidence, '']
    }));
  };

  const handleUpdateEvidence = (index: number, value: string) => {
    setNewTruth(prev => ({
      ...prev,
      evidence: prev.evidence.map((e, i) => i === index ? value: e)
    }));
  };

  const handleRemoveEvidence = (index: number) => {
    setNewTruth(prev => ({
      ...prev,
      evidence: prev.evidence.filter((_, i) => i !== index)
    }));
  };

  const handleAddTag = () => {
    setNewTruth(prev => ({
      ...prev,
      tags: [...prev.tags, '']
    }));
  };

  const handleUpdateTag = (index: number, value: string) => {
    setNewTruth(prev => ({
      ...prev,
      tags: prev.tags.map((t, i) => i === index ? value: t)
    }));
  };

  const handleRemoveTag = (index: number) => {
    setNewTruth(prev => ({
      ...prev,
      tags: prev.tags.filter((_, i) => i !== index)
    }));
  };

  const handleAddActionItem = () => {
    setNewTruth(prev => ({
      ...prev,
      actionitems: [...prev.action_items, '']
    }));
  };

  const handleUpdateActionItem = (index: number, value: string) => {
    setNewTruth(prev => ({
      ...prev,
      actionitems: prev.action_items.map((a, i) => i === index ? value: a)
    }));
  };

  const handleRemoveActionItem = (index: number) => {
    setNewTruth(prev => ({
      ...prev,
      actionitems: prev.action_items.filter((_, i) => i !== index)
    }));
  };

  const filteredTruths = truths.filter(truth => {
    if (selectedCategory !== 'all' && truth.category !== selectedCategory) return false;
    if (searchQuery && !truth.title.toLowerCase().includes(searchQuery.toLowerCase()) && 
        !truth.description.toLowerCase().includes(searchQuery.toLowerCase())) return false;
    return true;
  });

  const filteredInsights = insights.filter(insight => {
    if (searchQuery && !insight.title.toLowerCase().includes(searchQuery.toLowerCase()) && 
        !insight.description.toLowerCase().includes(searchQuery.toLowerCase())) return false;
    return true;
  });

  const getCategoryColor = (category: string) => {
    switch (category) {
      case 'business': return 'bg-blue-100 text-blue-800';
      case 'personal': return 'bg-green-100 text-green-800';
      case 'technical': return 'bg-purple-100 text-purple-800';
      case 'strategic': return 'bg-orange-100 text-orange-800';
      case 'operational': return 'bg-gray-100 text-gray-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  const getImpactColor = (impact: string) => {
    switch (impact) {
      case 'high': return 'bg-red-100 text-red-800';
      case 'medium': return 'bg-yellow-100 text-yellow-800';
      case 'low': return 'bg-green-100 text-green-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'verified': return 'bg-green-100 text-green-800';
      case 'pending': return 'bg-yellow-100 text-yellow-800';
      case 'disputed': return 'bg-red-100 text-red-800';
      case 'archived': return 'bg-gray-100 text-gray-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  if (loading) {
    return (
      <div className={`space-y-6 ${className}`}>
        <div className="flex items-center justify-center py-12">
          <RefreshCw className="h-8 w-8 animate-spin text-primary" />
          <span className="ml-3 text-lg">Loading your knowledge center...</span>
        </div>
      </div>
    );
  }

  return (
    <div className={`space-y-6 ${className}`}>
      {/* Living RAG System Status */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Brain className="h-5 w-5 text-blue-600" />
            Living RAG System
            <Badge variant={realTimeUpdates ? "default" : "secondary"} className="ml-2">
              {realTimeUpdates ? "Active" : "Paused"}
            </Badge>
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md: grid-cols-3 gap-4">
            {/* Data Streams Status */}
            <div className="space-y-2">
              <div className="flex items-center gap-2">
                <Database className="h-4 w-4 text-green-600" />
                <span className="text-sm font-medium">Data Streams</span>
              </div>
              <div className="text-2xl font-bold">{dataStreams.length}</div>
              <div className="text-xs text-muted-foreground">
                {dataStreams.filter(s => s.status === 'active').length} active
              </div>
            </div>

            {/* Auto Discovery Status */}
            <div className="space-y-2">
              <div className="flex items-center gap-2">
                <Cpu className="h-4 w-4 text-purple-600" />
                <span className="text-sm font-medium">Auto Discovery</span>
              </div>
              <div className="text-2xl font-bold">
                {autoDiscoveryEnabled ? "Enabled" : "Disabled"}
              </div>
              <div className="text-xs text-muted-foreground">
                Last run: {lastDiscoveryRun ? lastDiscoveryRun.toLocaleTimeString() : "Never"}
              </div>
            </div>

            {/* Discovery Progress */}
            <div className="space-y-2">
              <div className="flex items-center gap-2">
                <Activity className="h-4 w-4 text-orange-600" />
                <span className="text-sm font-medium">Discovery Progress</span>
              </div>
              <Progress value={discoveryProgress} className="h-2" />
              <div className="text-xs text-muted-foreground">
                {discoveryProgress}% complete
              </div>
            </div>
          </div>

          {/* Active Data Sources */}
          {activeDataSources.length > 0 && (
            <div className="mt-4">
              <div className="flex items-center gap-2 mb-2">
                <Network className="h-4 w-4 text-blue-600" />
                <span className="text-sm font-medium">Active Data Sources</span>
              </div>
              <div className="flex flex-wrap gap-2">
                {activeDataSources.map(source => (
                  <Badge key={source} variant="outline" className="text-xs">
                    {source}
                  </Badge>
                ))}
              </div>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Data Streams Dashboard */}
      {dataStreams.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Database className="h-5 w-5 text-green-600" />
              Data Streams
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-3">
              {dataStreams.map(stream => (
                <div key={stream.id} className="flex items-center justify-between p-3 border rounded-lg">
                  <div className="flex items-center gap-3">
                    <div className={`w-3 h-3 rounded-full ${
                      stream.status === 'active' ? 'bg-green-500' : 
                      stream.status === 'error' ? 'bg-red-500' : 'bg-gray-400'
                    }`} />
                    <div>
                      <div className="font-medium">{stream.integration_name}</div>
                      <div className="text-sm text-muted-foreground">{stream.data_type}</div>
                    </div>
                  </div>
                  <div className="text-right">
                    <div className="text-sm font-medium">{stream.record_count} records</div>
                    <div className="text-xs text-muted-foreground">
                      {stream.truth_contributions} truths generated
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Main Content */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <h1 className="text-2xl font-bold">Knowledge Center</h1>
          <Badge variant="outline" className="text-xs">
            {truths.length} Truths â€¢ {insights.length} Insights
          </Badge>
        </div>
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={handleRefresh}
            disabled={loading}
          >
            <RefreshCw className={`h-4 w-4 ${loading ? 'animate-spin' : ''}`} />
            Refresh
          </Button>
          <Button
            onClick={() => setShowAddTruth(true)}
            size="sm"
          >
            <Plus className="h-4 w-4" />
            Add Truth
          </Button>
        </div>
      </div>

      {/* Search and Filter */}
      <Card>
        <CardContent className="p-6">
          <div className="flex flex-col md: flex-row gap-4">
            <div className="flex-1">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Search truths and insights..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="pl-10"
                />
              </div>
            </div>
            <div className="flex gap-2">
              <Select value={selectedCategory} onValueChange={setSelectedCategory}>
                <SelectTrigger className="w-48">
                  <SelectValue placeholder="All Categories" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Categories</SelectItem>
                  <SelectItem value="business">Business</SelectItem>
                  <SelectItem value="personal">Personal</SelectItem>
                  <SelectItem value="technical">Technical</SelectItem>
                  <SelectItem value="strategic">Strategic</SelectItem>
                  <SelectItem value="operational">Operational</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Main Content */}
      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <TabsList className="grid w-full grid-cols-2">
          <TabsTrigger value="truths">Verified Truths ({truths.filter(t => t.status === 'verified').length})</TabsTrigger>
          <TabsTrigger value="insights">AI Insights ({insights.length})</TabsTrigger>
        </TabsList>

        <TabsContent value="truths" className="mt-6">
          {filteredTruths.length === 0 ? (
            <Card>
              <CardContent className="text-center py-12">
                <Brain className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
                <p className="text-lg font-medium mb-2">No truths discovered yet</p>
                <p className="text-muted-foreground mb-4">
                  Continue using Nexus to capture thoughts and data. We'll uncover truths as patterns emerge.
                </p>
                <Button onClick={() => setShowAddTruth(true)}>
                  <Plus className="h-4 w-4 mr-2" />
                  Add Your First Truth
                </Button>
              </CardContent>
            </Card>
          ) : (
            <div className="grid grid-cols-1 md: grid-cols-2 lg:grid-cols-3 gap-6">
              {filteredTruths.map((truth) => (
                <Card key={truth.id} className="hover: shadow-lg transition-shadow">
                  <CardHeader>
                    <div className="flex items-start justify-between">
                      <div className="flex items-center gap-2">
                        <div className={`p-2 rounded-full ${getCategoryColor(truth.category)}`}>
                          <Lightbulb className="h-4 w-4" />
                        </div>
                        <div>
                          <CardTitle className="text-lg">{truth.title}</CardTitle>
                          <div className="flex items-center gap-2 mt-2">
                            <Badge variant="outline" className={getCategoryColor(truth.category)}>
                              {truth.category}
                            </Badge>
                            <Badge variant="outline" className={getImpactColor(truth.impact)}>
                              {truth.impact} impact
                            </Badge>
                            <Badge variant="outline" className={getStatusColor(truth.status)}>
                              {truth.status}
                            </Badge>
                          </div>
                        </div>
                      </div>
                      <div className="flex items-center gap-1">
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => setSelectedTruth(truth)}
                        >
                          <Eye className="h-4 w-4" />
                        </Button>
                        {truth.status === 'pending' && (
                          <>
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => handleVerifyTruth(truth.id)}
                            >
                              <CheckCircle2 className="h-4 w-4 text-green-600" />
                            </Button>
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => handleDisputeTruth(truth.id)}
                            >
                              <AlertCircle className="h-4 w-4 text-red-600" />
                            </Button>
                          </>
                        )}
                      </div>
                    </div>
                  </CardHeader>
                  <CardContent>
                    <p className="text-sm text-muted-foreground mb-4 line-clamp-3">
                      {truth.description}
                    </p>
                    <div className="space-y-2">
                      <div className="flex items-center justify-between text-sm">
                        <span className="text-muted-foreground">Confidence: </span>
                        <span className="font-medium">{Math.round(truth.confidence * 100)}%</span>
                      </div>
                      <Progress value={truth.confidence * 100} className="h-2" />
                    </div>
                    {truth.actionable && truth.action_items.length > 0 && (
                      <div className="mt-4">
                        <p className="text-sm font-medium mb-2">Action Items: </p>
                        <ul className="space-y-1">
                          {truth.action_items.slice(0, 2).map((item, index) => (
                            <li key={index} className="text-xs text-muted-foreground flex items-start gap-2">
                              <ArrowRight className="h-3 w-3 mt-0.5 flex-shrink-0" />
                              {item}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
        </TabsContent>

        <TabsContent value="insights" className="mt-6">
          {filteredInsights.length === 0 ? (
            <Card>
              <CardContent className="text-center py-12">
                <TrendingUp className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
                <p className="text-lg font-medium mb-2">No insights yet</p>
                <p className="text-muted-foreground mb-4">
                  Connect more integrations and capture more thoughts to generate AI insights.
                </p>
              </CardContent>
            </Card>
          ) : (
            <div className="space-y-4">
              {filteredInsights.map((insight) => (
                <Card key={insight.id} className="hover: shadow-md transition-shadow">
                  <CardContent className="p-6">
                    <div className="flex items-start justify-between mb-4">
                      <div className="flex items-center gap-3">
                        <div className={`p-2 rounded-full ${getImpactColor(insight.impact)}`}>
                          <TrendingUp className="h-4 w-4" />
                        </div>
                        <div className="flex-1">
                          <h3 className="font-medium text-lg">{insight.title}</h3>
                          <p className="text-sm text-muted-foreground">{insight.description}</p>
                        </div>
                      </div>
                      <div className="flex items-center gap-2">
                        <Badge variant="outline" className={getImpactColor(insight.impact)}>
                          {insight.impact} impact
                        </Badge>
                        <Badge variant="outline" className="text-blue-600">
                          {Math.round(insight.confidence * 100)}% confidence
                        </Badge>
                      </div>
                    </div>
                    
                    <div className="grid grid-cols-2 md: grid-cols-4 gap-4 text-sm">
                      <div>
                        <span className="text-muted-foreground">Type:</span>
                        <p className="font-medium capitalize">{insight.type}</p>
                      </div>
                      <div>
                        <span className="text-muted-foreground">Source:</span>
                        <p className="font-medium">{insight.source}</p>
                      </div>
                      <div>
                        <span className="text-muted-foreground">Data Points:</span>
                        <p className="font-medium">{insight.dataPoints}</p>
                      </div>
                      <div>
                        <span className="text-muted-foreground">Urgency:</span>
                        <p className="font-medium capitalize">{insight.urgency.replace('-', ' ')}</p>
                      </div>
                    </div>

                    {insight.actionable && insight.actionUrl && (
                      <div className="mt-4 pt-4 border-t">
                        <Button variant="outline" size="sm" onClick={() => window.open(insight.actionUrl, '_blank')}>
                          <ArrowRight className="h-4 w-4 mr-2" />
                          Take Action
                        </Button>
                      </div>
                    )}
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
        </TabsContent>
      </Tabs>

      {/* Truth Detail Dialog */}
      {selectedTruth && (
        <Dialog open={!!selectedTruth} onOpenChange={() => setSelectedTruth(null)}>
          <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
            <DialogHeader>
              <DialogTitle className="flex items-center gap-2">
                <Lightbulb className="h-5 w-5" />
                {selectedTruth.title}
              </DialogTitle>
            </DialogHeader>
            
            <div className="space-y-6">
              <div>
                <h4 className="font-semibold mb-2">Description</h4>
                <p className="text-muted-foreground">{selectedTruth.description}</p>
              </div>

              <div className="grid grid-cols-1 md: grid-cols-2 gap-6">
                <div>
                  <h4 className="font-semibold mb-2">Evidence</h4>
                  <ul className="space-y-2">
                    {selectedTruth.evidence.map((item, index) => (
                      <li key={index} className="flex items-start gap-2 text-sm">
                        <CheckCircle2 className="h-4 w-4 text-green-600 mt-0.5 flex-shrink-0" />
                        {item}
                      </li>
                    ))}
                  </ul>
                </div>

                <div>
                  <h4 className="font-semibold mb-2">Details</h4>
                  <div className="space-y-2 text-sm">
                    <div className="flex justify-between">
                      <span className="text-muted-foreground">Category: </span>
                      <Badge variant="outline" className={getCategoryColor(selectedTruth.category)}>
                        {selectedTruth.category}
                      </Badge>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-muted-foreground">Confidence: </span>
                      <span>{Math.round(selectedTruth.confidence * 100)}%</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-muted-foreground">Impact: </span>
                      <Badge variant="outline" className={getImpactColor(selectedTruth.impact)}>
                        {selectedTruth.impact}
                      </Badge>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-muted-foreground">Status: </span>
                      <Badge variant="outline" className={getStatusColor(selectedTruth.status)}>
                        {selectedTruth.status}
                      </Badge>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-muted-foreground">Source: </span>
                      <span>{selectedTruth.source}</span>
                    </div>
                  </div>
                </div>
              </div>

              {selectedTruth.actionable && selectedTruth.action_items.length > 0 && (
                <div>
                  <h4 className="font-semibold mb-2">Action Items</h4>
                  <ul className="space-y-2">
                    {selectedTruth.action_items.map((item, index) => (
                      <li key={index} className="flex items-start gap-2 text-sm">
                        <ArrowRight className="h-4 w-4 text-primary mt-0.5 flex-shrink-0" />
                        {item}
                      </li>
                    ))}
                  </ul>
                </div>
              )}

              <div>
                <h4 className="font-semibold mb-2">Tags</h4>
                <div className="flex flex-wrap gap-2">
                  {selectedTruth.tags.map((tag, index) => (
                    <Badge key={index} variant="secondary">
                      {tag}
                    </Badge>
                  ))}
                </div>
              </div>
            </div>
          </DialogContent>
        </Dialog>
      )}

      {/* Add Truth Dialog */}
      <Dialog open={showAddTruth} onOpenChange={setShowAddTruth}>
        <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <Plus className="h-5 w-5" />
              Add New Truth
            </DialogTitle>
          </DialogHeader>
          
          <div className="space-y-6">
            {/* Basic Information */}
            <div className="grid grid-cols-1 md: grid-cols-2 gap-6">
              <div>
                <Label htmlFor="title">Title</Label>
                <Input
                  id="title"
                  value={newTruth.title}
                  onChange={(e) => setNewTruth(prev => ({ ...prev, title: e.target.value }))}
                  placeholder="Enter truth title"
                />
              </div>
              
              <div>
                <Label htmlFor="category">Category</Label>
                <Select value={newTruth.category} onValueChange={(value: any) => setNewTruth(prev => ({ ...prev, category: value }))}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="business">Business</SelectItem>
                    <SelectItem value="personal">Personal</SelectItem>
                    <SelectItem value="technical">Technical</SelectItem>
                    <SelectItem value="strategic">Strategic</SelectItem>
                    <SelectItem value="operational">Operational</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>

            <div>
              <Label htmlFor="description">Description</Label>
              <Textarea
                id="description"
                value={newTruth.description}
                onChange={(e) => setNewTruth(prev => ({ ...prev, description: e.target.value }))}
                placeholder="Describe the truth you've discovered"
                rows={3}
              />
            </div>

            <div className="grid grid-cols-1 md: grid-cols-3 gap-6">
              <div>
                <Label htmlFor="confidence">Confidence ({(newTruth.confidence * 100).toFixed(0)}%)</Label>
                <input
                  type="range"
                  min="0"
                  max="1"
                  step="0.1"
                  value={newTruth.confidence}
                  onChange={(e) => setNewTruth(prev => ({ ...prev, confidence: parseFloat(e.target.value) }))}
                  className="w-full"
                />
              </div>
              
              <div>
                <Label htmlFor="impact">Impact</Label>
                <Select value={newTruth.impact} onValueChange={(value: any) => setNewTruth(prev => ({ ...prev, impact: value }))}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="high">High</SelectItem>
                    <SelectItem value="medium">Medium</SelectItem>
                    <SelectItem value="low">Low</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              
              <div>
                <Label htmlFor="source">Source</Label>
                <Input
                  id="source"
                  value={newTruth.source}
                  onChange={(e) => setNewTruth(prev => ({ ...prev, source: e.target.value }))}
                  placeholder="e.g., Thought Analysis, Business Data"
                />
              </div>
            </div>

            {/* Evidence */}
            <div>
              <div className="flex items-center justify-between mb-2">
                <Label>Evidence</Label>
                <Button type="button" variant="outline" size="sm" onClick={handleAddEvidence}>
                  <Plus className="h-4 w-4 mr-2" />
                  Add Evidence
                </Button>
              </div>
              <div className="space-y-2">
                {newTruth.evidence.map((evidence, index) => (
                  <div key={index} className="flex gap-2">
                    <Input
                      value={evidence}
                      onChange={(e) => handleUpdateEvidence(index, e.target.value)}
                      placeholder="Enter evidence point"
                    />
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => handleRemoveEvidence(index)}
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  </div>
                ))}
              </div>
            </div>

            {/* Tags */}
            <div>
              <div className="flex items-center justify-between mb-2">
                <Label>Tags</Label>
                <Button type="button" variant="outline" size="sm" onClick={handleAddTag}>
                  <Plus className="h-4 w-4 mr-2" />
                  Add Tag
                </Button>
              </div>
              <div className="space-y-2">
                {newTruth.tags.map((tag, index) => (
                  <div key={index} className="flex gap-2">
                    <Input
                      value={tag}
                      onChange={(e) => handleUpdateTag(index, e.target.value)}
                      placeholder="Enter tag"
                    />
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => handleRemoveTag(index)}
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  </div>
                ))}
              </div>
            </div>

            {/* Action Items */}
            <div>
              <div className="flex items-center justify-between mb-2">
                <Label>Action Items</Label>
                <Button type="button" variant="outline" size="sm" onClick={handleAddActionItem}>
                  <Plus className="h-4 w-4 mr-2" />
                  Add Action Item
                </Button>
              </div>
              <div className="space-y-2">
                {newTruth.action_items.map((item, index) => (
                  <div key={index} className="flex gap-2">
                    <Input
                      value={item}
                      onChange={(e) => handleUpdateActionItem(index, e.target.value)}
                      placeholder="Enter action item"
                    />
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => handleRemoveActionItem(index)}
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  </div>
                ))}
              </div>
            </div>

            {/* Action Buttons */}
            <div className="flex justify-end gap-2 pt-4 border-t">
              <Button variant="outline" onClick={() => setShowAddTruth(false)}>
                Cancel
              </Button>
              <Button onClick={handleAddTruth} disabled={!newTruth.title.trim()}>
                <Plus className="h-4 w-4 mr-2" />
                Add Truth
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}; 